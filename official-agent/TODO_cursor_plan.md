# TODO: Cursor Plan

Рабочий документ для разработки официального агента на базе `sgr_deep_research`. Любые изменения в коде выполняются только после явного разрешения и с минимальным вмешательством.

1. Зафиксировать ограничения и определить точку входа/оркестратор проекта.
   - 1.1 [DONE] Изучить текущий orchestrator в `sgr_deep_research/__main__.py`: FastAPI-приложение инициализирует пайплайн через `GlobalConfig` → `AgentFactory` → `AgentRegistry`/`ToolRegistry`. Субагентов планируем подключать через конфигурацию (новые определения агентов/инструментов в `default_definitions.py` или через YAML-конфиги), чтобы не модифицировать основной код `sgr_deep_research`.
   - 1.2 [DONE] Формально зафиксировать ограничения: (1) Русская локализация: все ответы пользователю и финальные документы на русском языке; (2) Запрет на самостоятельные запуски: не запускать код, скрипты, команды без явного разрешения пользователя; (3) Минимальные правки в `sgr_deep_research`: изменения только через конфигурацию (YAML-файлы, `default_definitions.py`), без модификации основного кода проекта.
   - 1.3 [DONE] Определить формат данных: для минимизации изменений в `sgr_deep_research` в `ResearchContext` добавляется только одно общее поле `custom_context: dict | BaseModel | None` (тип определяется в проектах-наследниках). В проекте `official-agent` создается класс `OfficialAgentContext` (Pydantic BaseModel) с полями: `user_position`, `documents` (список документов, т.к. в рамках одной задачи может потребоваться разработка нескольких документов), `collected_data`, `verification_results`. Этот объект хранится в `ResearchContext.custom_context`. Субагенты вызываются через специальные инструменты (Tool) в фазе `_action_phase` главного агента. Данные также передаются через `conversation` history. Формат: структурированные Pydantic-модели для каждого типа данных.
   - 1.4 [DONE] Архитектура наследования агентов: все субагенты являются потомками `SGRToolCallingAgent` (из `sgr_deep_research/core/agents/sgr_tool_calling_agent.py`). Прямых потомков `SGRToolCallingAgent` будет два: (1) Агент с LLM qwen3-32b - для продакшн использования; (2) Агент с LLM DeepSeek - только для разработки и отладки (используется для генерации недостающих нормативных документов и имитации ответов на запросы недостающей информации). В продакшн все обращения к DeepSeek должны быть заменены на обращения к системе документооборота. У дальнейших потомков конкретизируем перечень доступных инструментов через параметр `toolkit: list[Type[BaseTool]]` в конструкторе.
   - 1.4.1 [PENDING] Рекомендации по безопасной реализации использования DeepSeek как имитатора: (1) Создать интерфейс `DocumentSystemInterface` с реализациями `MockDocumentSystem` (DeepSeek) и `RealDocumentSystem` для легкой замены; (2) Использовать явные флаги конфигурации (например, `USE_MOCK_DOCUMENT_SYSTEM=True` в dev, `False` в prod) для предотвращения случайного использования имитации в продакшн; (3) Перед продакшн обязательно протестировать на реальных данных/документах; (4) Документировать процесс переключения на реальную систему; (5) Добавить валидацию форматов данных, чтобы имитация максимально соответствовала реальной системе.
   - 1.5 [DONE] Минимальное изменение в `sgr_deep_research`: добавлено в `ResearchContext` (файл `sgr_deep_research/core/models.py`) одно поле `custom_context: dict | BaseModel | None = Field(default=None, description="Custom context for project-specific data")`. Это позволяет проектам-наследникам хранить свои данные без модификации основного кода. **ВАЖНО**: Изменение внесено в форк, создан Pull Request (PR) в upstream репозиторий `sgr_deep_research`. PR содержит: (1) Минимальное изменение (только одно поле); (2) Обоснование необходимости (расширяемость для проектов-наследников); (3) Обратную совместимость (поле опциональное, не ломает существующий код). Разработка продолжается с использованием форка с этим изменением.
   - 1.5.1 [DONE] Создать отдельную ветку в форке `sgr_deep_research`: создана ветка `feature/add-custom-context-field` от актуальной версии upstream/main. Форк синхронизирован с upstream.
   - 1.5.2 [DONE] Внести изменение в `ResearchContext`: добавлено поле `custom_context: dict | BaseModel | None = Field(default=None, description="Custom context for project-specific data")` в класс `ResearchContext` (файл `sgr_deep_research/core/models.py`). Изменение внесено в ветку `feature/add-custom-context-field`. Ошибок линтера нет.
   - 1.5.3 [DONE] Создать Pull Request в upstream: сформирован PR из ветки `feature/add-custom-context-field` в upstream репозиторий. PR содержит описание изменения, обоснование необходимости, информацию об обратной совместимости. Разработка продолжается с использованием форка с этим изменением.
   - 1.6 [DONE] Создать класс `OfficialAgentContext` (Pydantic BaseModel) в проекте `official-agent` с полями для хранения данных официального агента: `user_position`, `documents` (список `DocumentTask` - каждый документ со своим типом, статусом, данными), `data_collection_plan`, `verification_results`. Этот класс будет использоваться для хранения в `ResearchContext.custom_context`. Поддержать возможность добавления новых документов при эскалации. Создан файл `official-agent/core/models.py` с полным набором моделей данных.
2. Структурировать требования из `core/prompts/system_prompt.txt` и описать вход/выход инструментов (Tools) для субагентов.
   - 2.0 [DONE] Принцип реализации инструментов: каждый инструмент может работать двумя способами - (1) вызвать субагента (LLM) с промптом и обработать текстовый ответ, или (2) выполнить задачу алгоритмически без использования LLM. Выбор подхода для каждого инструмента определяется по мере разработки в зависимости от сложности задачи и доступности алгоритмических решений.
   - 2.1 [PENDING] Инструмент "Ролевой Аналитик" (Tool): Вход из `ResearchContext` - исходный запрос пользователя из `task`, `conversation` history. Инструмент может вызвать субагента или выполнить алгоритмически. Результат сохраняется в `ResearchContext.custom_context.OfficialAgentContext`: `user_position`, `authority_level`, `allowed_document_types`, `job_responsibilities`. Требования: CORE_WORKFLOW п.1, AUTHORIZATION_VALIDATION_PROTOCOL п.1-2.
   - 2.2 [PENDING] Инструмент "Классификатор задач" (Tool): Вход из `ResearchContext.custom_context` - `user_position`, исходный запрос из `task`. Инструмент может вызвать субагента или выполнить алгоритмически. Результат сохраняется: список `DocumentTask` (каждый с `document_type`, `template_id`, `is_within_authority`, `status`, `source` - исходный запрос или эскалация). Инструмент должен определять все необходимые документы для задачи, включая те, что могут потребоваться при эскалации. Требования: CORE_WORKFLOW п.2, AUTHORIZATION_VALIDATION_PROTOCOL п.3-5.
   - 2.3 [PENDING] Инструмент "Планировщик сбора данных" (Tool): Вход из `ResearchContext.custom_context` - список `documents`, `user_position`. Инструмент может вызвать субагента или выполнить алгоритмически. Результат сохраняется: `data_collection_plan` (план с приоритетами согласно PRIORITY_HIERARCHY, учитывающий требования всех документов), список источников. Планировщик должен объединять требования всех документов в единый план сбора данных. Требования: CORE_WORKFLOW п.3, PRIORITY_HIERARCHY (14 пунктов).
   - 2.4 [PENDING] Инструмент "Верификатор данных" (Tool): Вход из `ResearchContext.custom_context` - `collected_data`, список `documents`. Инструмент может вызвать субагента или выполнить алгоритмически. Результат сохраняется: `verified_data`, `verification_results` (для каждого документа отдельно), `conflicts`, `missing_data`. Верификатор должен проверять данные для всех документов. Требования: DATA_VERIFICATION_STANDARDS, DATE_HANDLING_GUIDELINES, ESCALATION_PROTOCOL п.2.
   - 2.5 [PENDING] Инструмент "Сборщик документов" (Tool): Вход из `ResearchContext.custom_context` - список `documents`, `verified_data`, `user_position`. Инструмент может вызвать субагента или выполнить алгоритмически. Результат сохраняется: для каждого документа в списке генерируется `final_document` (на русском языке) и сохраняется в соответствующем `DocumentTask`. Инструмент должен обрабатывать все документы последовательно или параллельно. Требования: CORE_WORKFLOW п.4, OPERATIONAL_PRINCIPLES п.5-6, LANGUAGE_GUIDELINES.
   - 2.6 [PENDING] Инструмент "Контроль соответствия" (Tool): Вход из `ResearchContext.custom_context` - список `documents` с `final_document` для каждого, все собранные данные. Инструмент может вызвать субагента или выполнить алгоритмически. Результат сохраняется: `compliance_report` (для каждого документа отдельно), `issues`, `is_ready` (общий флаг готовности всех документов). Контроль должен проверять все документы. Требования: CORE_WORKFLOW п.5, OPERATIONAL_PRINCIPLES п.4, DATA_VERIFICATION_STANDARDS.
3. Спроектировать последовательность и форматы данных для всех субагентов.
   - 3.1 [PENDING] Последовательность выполнения (workflow): (1) Ролевой Аналитик → (2) Классификатор задач (определяет список документов) → (3) Планировщик сбора данных (для всех документов) → (4) Сбор данных (может быть несколько итераций с разными источниками) → (5) Верификатор данных (для всех документов) → (6) Сборщик документов (обрабатывает все документы) → (7) Контроль соответствия (проверяет все документы). Если на этапе (2) или (4) обнаружено превышение полномочий - добавляются документы эскалации в список `documents`, и workflow продолжается с учетом новых документов. Если недостаток данных - эскалация/запрос уточнений. Последовательность соответствует CORE_WORKFLOW из system_prompt.txt.
   - 3.2 [DONE] Форматы данных для OfficialAgentContext: определены структуры Pydantic-моделей для каждого поля: `UserPosition` (должность, уровень полномочий, список допустимых документов, обязанности), `DocumentTask` (модель для каждого документа: `document_id`, `document_type`, `template_id`, `is_within_authority`, `status`, `source` - исходный запрос/эскалация, `final_document`, `compliance_report`), список `documents: list[DocumentTask]`, `DataCollectionPlan` и `DataCollectionItem` (план с приоритетами, список источников, статусы выполнения), `VerificationResults` и `VerificationResult` (верифицированные данные, конфликты через `Conflict`, отсутствующие данные через `MissingData` для каждого документа), `ComplianceReport` и `ComplianceCheckItem` (отчет, замечания, флаг готовности для каждого документа). Все модели созданы в `official-agent/core/models.py`.
   - 3.3 [PENDING] Детализация структуры OfficialAgentContext: описать типы данных для каждого поля, включая вложенные модели (например, для CollectedData нужны модели для каждого приоритета: законодательство, инструкции, ресурсы, погода и т.д.). Определить обязательные и опциональные поля, значения по умолчанию.
   - 3.4 [DONE] Поддержка множественных документов: в рамках одной задачи может потребоваться разработка нескольких документов. Все документы хранятся в списке `OfficialAgentContext.documents` как `DocumentTask`. При эскалации (превышение полномочий) документы эскалации автоматически добавляются в этот список и обрабатываются в рамках того же workflow. Каждый `DocumentTask` имеет свой статус обработки (`DocumentStatus`), что позволяет отслеживать прогресс по каждому документу независимо. Структура данных поддерживает обработку списка документов на всех этапах. Workflow логика для обработки множественных документов будет реализована в инструментах.
4. Проработать модуль "Ролевой Аналитик" (структуры ролей, полномочия, API).
   - 4.1 [PENDING] Структура данных для ролей: создать Pydantic-модель `UserPosition` с полями: `position_name` (название должности), `position_id` (идентификатор), `authority_level` (уровень полномочий - числовой или enum), `allowed_document_types` (список допустимых типов документов), `job_responsibilities` (список обязанностей), `supervisor_position` (должность непосредственного руководителя), `subordinate_positions` (список подчиненных должностей). Модель должна поддерживать иерархию должностей.
   - 4.2 [PENDING] API/интерфейс для получения информации о ролях: определить интерфейс `RoleRepository` (или аналогичный) для получения данных о должностях. В dev-режиме может использовать DeepSeek для генерации данных, в prod - обращение к системе документооборота/базе данных должностей. Методы: `get_position_by_name(name: str) -> UserPosition`, `get_position_by_id(id: str) -> UserPosition`, `get_allowed_documents(position: UserPosition) -> list[str]`, `get_job_responsibilities(position: UserPosition) -> list[str]`.
   - 4.3 [PENDING] Логика извлечения должности из запроса: описать алгоритм/промпт для LLM или алгоритмический парсинг текста запроса пользователя для определения должности. Учесть различные варианты упоминания должности (полное название, сокращение, контекстные упоминания). Результат - идентификатор или название должности для последующего запроса через API.
   - 4.4 [PENDING] Логика проверки полномочий: описать правила проверки соответствия запрашиваемого типа документа полномочиям должности. Создать функцию `check_authority(position: UserPosition, document_type: str) -> bool` или более детальную модель `AuthorityCheckResult` с флагом соответствия и обоснованием.
5. Проработать модуль “Классификатор задач” (логика выбора документа, шаблоны).
   - 5.1 [PENDING] Структура данных для типов документов: создать Pydantic-модель `DocumentType` с полями: `type_id` (идентификатор типа), `type_name` (название типа документа), `description` (описание назначения), `required_authority_level` (минимальный уровень полномочий), `template_id` (идентификатор шаблона), `required_fields` (список обязательных полей для заполнения), `category` (категория документа). Поддержать иерархию типов документов.
   - 5.2 [PENDING] Логика выбора типа документа: описать алгоритм/промпт для LLM определения типов документов на основе запроса пользователя и должности. Учесть контекст запроса, ключевые слова, историю conversation. Результат - список `DocumentType` (т.к. в рамках одной задачи может потребоваться несколько документов) или список кандидатов с вероятностями. Функция `classify_document_types(user_request: str, position: UserPosition) -> list[DocumentType]`.
   - 5.3 [PENDING] Система шаблонов документов: определить структуру хранения шаблонов (файлы, база данных, система документооборота). Создать интерфейс `TemplateRepository` с методами: `get_template(template_id: str) -> DocumentTemplate`, `list_templates_for_document_type(document_type: str) -> list[DocumentTemplate]`. Модель `DocumentTemplate` должна содержать: `template_id`, `template_content` (текст шаблона с плейсхолдерами), `placeholders` (список полей для заполнения), `metadata` (метаданные шаблона).
   - 5.4 [PENDING] Проверка соответствия полномочиям: интегрировать с модулем "Ролевой Аналитик" для проверки, находится ли выбранный тип документа в списке `allowed_document_types` должности. Функция `check_document_authority(position: UserPosition, document_type: DocumentType) -> AuthorityCheckResult` с результатом: `is_within_authority` (bool), `reason` (обоснование), `escalation_required` (требуется ли эскалация).
   - 5.5 [PENDING] Обработка случаев превышения полномочий и неясности: описать логику для случаев: (1) Превышение полномочий - добавление документа эскалации к руководителю в список `documents` с обоснованием (документ эскалации становится частью задачи); (2) Неясность типа документа - запрос уточнений у пользователя через `ClarificationTool` с вопросами о назначении и цели документа. Создать модель `ClassificationResult` с полями: `documents` (список `DocumentTask`), `needs_clarification`, `escalation_documents` (список документов эскалации, которые добавляются в общий список). При эскалации новые документы должны быть добавлены в `OfficialAgentContext.documents` и обработаны в рамках того же workflow.
6. Составить чек-лист данных для "Планировщика сбора данных" с приоритетами.
   - 6.1 [PENDING] Структура чек-листа данных: создать модель `DataCollectionItem` с полями: `priority` (число от 1 до 14 согласно PRIORITY_HIERARCHY), `category` (категория данных), `description` (описание что нужно собрать), `sources` (список источников данных), `status` (статус сбора: pending, in_progress, collected, failed), `collected_data` (собранные данные), `required_for_documents` (список документов, для которых нужны эти данные). Создать модель `DataCollectionPlan` как список `DataCollectionItem`, отсортированный по приоритету.
   - 6.2 [PENDING] Приоритет 1 - Законодательство РФ: обращение к российскому законодательству необходимо только при решении неоднозначных проблем, требующих уточнения на федеральном уровне. Примеры таких ситуаций: снос зданий, вырубка зеленых насаждений, привлечение работников к сверхурочным работам, экологические вопросы, вопросы безопасности и т.д. В остальных случаях достаточно руководствоваться ведомственными нормативными актами (приоритет 4). Описать логику определения необходимости обращения к законодательству РФ, источники (правовые базы, официальные сайты), формат данных (номера и даты документов, полные тексты, ссылки на актуальные версии).
   - 6.3 [PENDING] Приоритет 2 - Инструкции непосредственного руководителя: описать сбор данных о прямых указаниях руководителя (распоряжения, приказы, устные указания), источники (система документооборота, протоколы совещаний), формат данных.
   - 6.4 [PENDING] Приоритет 3 - Должностные обязанности и пределы полномочий: описать сбор данных о должностной инструкции, полномочиях должности, границах ответственности. Источники: должностные инструкции, регламенты, база должностей. Формат данных.
   - 6.5 [PENDING] Приоритет 4 - Регулятивные и руководящие документы: описать сбор данных о внутренних регламентах, стандартах, методических указаниях, относящихся к задаче. Источники: корпоративные базы документов, системы документооборота. Формат данных.
   - 6.6 [PENDING] Приоритет 5 - Графики работ и сроки: описать сбор данных о календарных планах, сроках выполнения работ, дедлайнах, критических датах. Источники: системы планирования, календари, планы работ. Формат данных (даты в формате YYYY-MM-DD).
   - 6.7 [PENDING] Приоритет 6 - Текущий статус выполнения работ: описать сбор данных о фактическом состоянии работ, проценте выполнения, достигнутых результатах, проблемах. Источники: отчеты о ходе работ, системы мониторинга. Формат данных.
   - 6.8 [PENDING] Приоритет 7 - Характеристики местности работ: описать сбор данных о рельефе, геологии, инфраструктуре, ограничениях территории. Источники: геодезические данные, проектная документация, отчеты. Формат данных.
   - 6.9 [PENDING] Приоритет 8 - Сезонные условия работ: описать сбор данных о сезонных ограничениях, оптимальных периодах для работ, сезонных рисках. Источники: нормативные документы, исторические данные, экспертные оценки. Формат данных.
   - 6.10 [PENDING] Приоритет 9 - Текущие и прогнозируемые погодные условия: описать сбор данных о температуре, осадках, ветре, видимости, прогнозах на период работ. Источники: метеослужбы, прогнозы погоды. Формат данных (даты в формате YYYY-MM-DD).
   - 6.11 [PENDING] Приоритет 10 - Благоприятные/препятствующие факторы выполнения работ: описать сбор данных о факторах, способствующих или препятствующих выполнению работ (экономические, технические, организационные). Источники: аналитические отчеты, экспертные оценки. Формат данных.
   - 6.12 [PENDING] Приоритет 11 - Наличие ресурсов (персонал, техника, оборудование, материалы): описать сбор данных о доступности персонала, техники, оборудования, материалов, их характеристиках, сроках поставки. Источники: системы учета ресурсов, базы данных поставщиков. Формат данных.
   - 6.13 [PENDING] Приоритет 12 - Административные документы руководителя: описать сбор данных о распоряжениях, приказах, указаниях руководителя, относящихся к задаче. Источники: система документооборота, архив документов. Формат данных.
   - 6.14 [PENDING] Приоритет 13 - Отчеты подчиненных должностных лиц: описать сбор данных о докладах, отчетах, информации от подчиненных. Источники: системы отчетности, документооборот. Формат данных.
   - 6.15 [PENDING] Приоритет 14 - Справочные материалы смежных должностных лиц: описать сбор данных о рекомендациях, справках, консультациях от коллег и смежных специалистов. Источники: межведомственное взаимодействие, консультации. Формат данных.
   - 6.16 [PENDING] Логика формирования плана сбора данных: описать алгоритм, который на основе списка документов (`DocumentTask`) и их требований формирует единый `DataCollectionPlan`, объединяя требования всех документов, устраняя дубликаты, сортируя по приоритетам. План должен учитывать зависимости между данными (например, погода влияет на график работ).
7. Описать правила "Верификатора данных" и сценарии эскалации.
   - 7.1 [PENDING] Структура результатов верификации: создать модель `VerificationResult` с полями: `document_id` (идентификатор документа), `verified_data` (верифицированные данные), `conflicts` (список конфликтов: `Conflict` с полями `field`, `value1`, `value2`, `source1`, `source2`, `resolution`), `missing_data` (список отсутствующих данных: `MissingData` с полями `field`, `description`, `priority`, `source`), `verification_status` (статус: verified, has_conflicts, missing_data, failed). Создать модель `VerificationResults` как список `VerificationResult` для всех документов.
   - 7.2 [PENDING] Правило 1 - Точные значения: описать логику извлечения точных значений из источников (даты, числа, имена). Верификатор должен проверять, что извлеченные значения точно соответствуют источникам, без интерпретаций и округлений. Создать функции проверки для каждого типа данных (даты, числа, строки).
   - 7.3 [PENDING] Правило 2 - Проверка года: описать логику подтверждения, что извлеченные данные соответствуют указанному году. Верификатор должен проверять соответствие всех дат и временных меток указанному году задачи. Функция `verify_year_consistency(data: dict, target_year: int) -> bool`.
   - 7.4 [PENDING] Правило 3 - Приоритизация источников: описать логику приоритизации источников: (1) Официальная документация имеет приоритет над вторичными источниками; (2) Прямо отвечающие фрагменты имеют приоритет над извлеченным контентом; (3) Множественные независимые подтверждающие источники повышают достоверность. Функция `prioritize_sources(sources: list[Source]) -> list[Source]`.
   - 7.5 [PENDING] Правило 4 - Точность дат: описать логику проверки точности дат с точностью до дня. Верификатор должен проверять формат дат (YYYY-MM-DD согласно DATE_HANDLING_GUIDELINES), валидность дат, соответствие календарю. Функция `verify_date_precision(date: str, expected_format: str = "YYYY-MM-DD") -> bool`.
   - 7.6 [PENDING] Правило 5 - Разрешение противоречий: описать логику обработки конфликтующей информации. При обнаружении противоречий между источниками верификатор должен: (1) Зафиксировать конфликт в `conflicts`; (2) Попытаться определить более надежный источник по правилу приоритизации; (3) Если невозможно разрешить - эскалировать к руководителю согласно ESCALATION_PROTOCOL п.2. Функция `resolve_contradictions(conflicts: list[Conflict]) -> ResolutionResult`.
   - 7.7 [PENDING] Сценарий эскалации 1 - Информация недоступна более 24 часов: описать логику отслеживания времени запроса данных. Если данные не получены в течение 24 часов, верификатор должен создать уведомление для непосредственного руководителя с описанием отсутствующих данных и причин задержки. Модель `EscalationNotification` с полями: `type`, `missing_data`, `request_time`, `elapsed_time`, `recipient` (руководитель).
   - 7.8 [PENDING] Сценарий эскалации 2 - Противоречивые официальные данные: описать логику подготовки запроса на уточнение при обнаружении противоречий в официальных данных. Верификатор должен создать документ-запрос с описанием противоречий, указанием источников и запросом уточнения. Документ добавляется в список `documents` для обработки.
   - 7.9 [PENDING] Сценарий эскалации 3 - Превышение полномочий: описать логику создания документа эскалации при обнаружении превышения полномочий (уже описано в пункте 5.5, но здесь нужно уточнить интеграцию с верификатором). Верификатор может обнаружить, что для выполнения задачи требуются данные, доступ к которым выходит за пределы полномочий должности.
   - 7.10 [PENDING] Сценарий эскалации 4 - Шаблон недоступен: описать логику подготовки запроса на получение соответствующего шаблона, если шаблон документа недоступен. Верификатор должен проверить доступность шаблонов для всех документов перед началом генерации.
   - 7.11 [PENDING] Интеграция верификации в workflow: описать, как верификатор интегрируется в общий workflow. Верификатор должен проверять данные для всех документов в списке `documents`, создавать `VerificationResults` для каждого документа, обрабатывать конфликты и отсутствующие данные, инициировать эскалации при необходимости. После верификации workflow может вернуться к сбору данных (если обнаружены пробелы) или продолжить к генерации документов.
8. Определить шаблоны и правила генерации текста для "Сборщика документов".
   - 8.1 [PENDING] Структура шаблонов документов: расширить модель `DocumentTemplate` (из пункта 5.3) с полями: `template_id`, `template_content` (текст шаблона с плейсхолдерами в формате `{field_name}` или `{{field_name}}`), `placeholders` (список полей: `Placeholder` с полями `name`, `type`, `required`, `description`, `validation_rules`), `sections` (структура документа: заголовки, разделы, подразделы), `metadata` (метаданные: версия шаблона, дата создания, автор, категория документа). Шаблоны должны поддерживать условные блоки и циклы для повторяющихся элементов.
   - 8.2 [PENDING] Правило 1 - Использование стандартных шаблонов: описать логику получения шаблонов из системы (через `TemplateRepository` из пункта 5.3). Сборщик документов должен использовать только стандартные шаблоны из доступных инструментов, не создавать шаблоны самостоятельно. Если шаблон недоступен - эскалация согласно ESCALATION_PROTOCOL п.4.
   - 8.3 [PENDING] Правило 2 - Анализ данных перед генерацией: описать логику анализа всех извлеченных данных перед началом генерации документа. Сборщик должен проверить наличие всех обязательных данных для заполнения плейсхолдеров, соответствие типов данных требованиям шаблона, полноту информации. Функция `analyze_data_for_template(template: DocumentTemplate, verified_data: dict) -> AnalysisResult`.
   - 8.4 [PENDING] Правило 3 - Заполнение плейсхолдеров: описать логику заполнения плейсхолдеров в шаблоне данными из `verified_data`. Сборщик должен: (1) Сопоставить поля шаблона с данными; (2) Применить валидацию согласно `validation_rules`; (3) Форматировать данные согласно типу плейсхолдера (даты в формате YYYY-MM-DD, числа с нужной точностью, тексты с правильным форматированием); (4) Обработать отсутствующие опциональные поля (оставить пустыми или использовать значения по умолчанию). Функция `fill_template(template: DocumentTemplate, data: dict) -> str`.
   - 8.5 [PENDING] Правило 4 - Языковые требования: описать правила генерации документов на русском языке. Все финальные документы должны быть полностью на русском языке согласно LANGUAGE_GUIDELINES. Внутренняя обработка может быть на английском для точности, но финальный вывод - только русский. Проверка языка должна быть частью валидации документа.
   - 8.6 [PENDING] Правило 5 - Не изобретать информацию: описать логику проверки, что в документ попадают только верифицированные данные из источников. Сборщик не должен генерировать или придумывать информацию, которая отсутствует в `verified_data`. Если данных недостаточно - документ не должен быть сгенерирован, требуется возврат к сбору данных или эскалация.
   - 8.7 [PENDING] Правило 6 - Форматирование документов: описать правила форматирования документов: структура (заголовки, разделы, подразделы), нумерация, списки, таблицы (если требуются), даты и числа в правильном формате, ссылки на источники (если требуются). Создать функцию `format_document(content: str, document_type: DocumentType) -> str`.
   - 8.8 [PENDING] Обработка множественных документов: описать логику обработки списка документов. Сборщик должен обрабатывать все документы из списка `documents`, для каждого использовать соответствующий шаблон, заполнять данными из `verified_data`, генерировать `final_document` и сохранять в соответствующий `DocumentTask`. Документы могут обрабатываться последовательно или параллельно (в зависимости от зависимостей между ними).
   - 8.9 [PENDING] Валидация сгенерированных документов: описать логику валидации сгенерированных документов перед сохранением. Проверки: (1) Все обязательные плейсхолдеры заполнены; (2) Данные соответствуют типам и валидационным правилам; (3) Документ на русском языке; (4) Форматирование корректно; (5) Нет изобретенной информации. Функция `validate_generated_document(document: str, template: DocumentTemplate, verified_data: dict) -> ValidationResult`.
9. Подготовить чек-лист финального контроля ("Контроль соответствия").
   - 9.1 [PENDING] Структура чек-листа контроля: создать модель `ComplianceCheckItem` с полями: `check_id` (идентификатор проверки), `category` (категория: workflow, data, language, formatting, authority), `description` (описание проверки), `status` (результат: passed, failed, warning), `details` (детали проверки), `required` (обязательная проверка или предупреждение). Создать модель `ComplianceReport` с полями: `document_id`, `checks` (список `ComplianceCheckItem`), `overall_status` (passed, failed, needs_review), `issues` (список проблем), `is_ready` (флаг готовности документа к отправке). Создать модель `ComplianceReports` как список `ComplianceReport` для всех документов.
   - 9.2 [PENDING] Проверка 1 - Соответствие CORE_WORKFLOW: описать проверки выполнения всех этапов workflow для каждого документа: (1) Должность определена (`user_position` заполнена); (2) Тип документа определен (`document_type` заполнен); (3) План сбора данных создан (`data_collection_plan` существует); (4) Данные собраны (все обязательные данные из плана получены); (5) Данные верифицированы (`verification_results` для документа существуют); (6) Документ сгенерирован (`final_document` существует). Функция `check_workflow_compliance(document: DocumentTask) -> ComplianceCheckItem`.
   - 9.3 [PENDING] Проверка 2 - Полнота информации: описать проверку, что все необходимая информация получена согласно OPERATIONAL_PRINCIPLES п.4. Контроль должен проверить: (1) Все обязательные данные из `data_collection_plan` собраны (статус `collected`); (2) Нет критических отсутствующих данных в `verification_results.missing_data`; (3) Все обязательные плейсхолдеры в шаблоне заполнены. Если информация неполная - документ не готов к отправке. Функция `check_data_completeness(document: DocumentTask, verification_results: VerificationResult) -> ComplianceCheckItem`.
   - 9.4 [PENDING] Проверка 3 - Соответствие DATA_VERIFICATION_STANDARDS: описать проверки соответствия стандартам верификации: (1) Все значения точные (без интерпретаций); (2) Год данных соответствует указанному году; (3) Источники приоритизированы правильно; (4) Даты точные (формат YYYY-MM-DD, день-уровень); (5) Противоречия разрешены или эскалированы. Функция `check_verification_standards(verification_results: VerificationResult) -> ComplianceCheckItem`.
   - 9.5 [PENDING] Проверка 4 - Языковые требования: описать проверку соответствия LANGUAGE_GUIDELINES. Контроль должен проверить: (1) Документ полностью на русском языке; (2) Нет смешения языков; (3) Терминология корректна. Функция `check_language_compliance(document: str) -> ComplianceCheckItem`.
   - 9.6 [PENDING] Проверка 5 - Форматирование и структура: описать проверки форматирования: (1) Структура документа соответствует шаблону (заголовки, разделы, подразделы); (2) Нумерация корректна; (3) Списки и таблицы (если есть) правильно оформлены; (4) Даты в правильном формате (YYYY-MM-DD); (5) Числа с правильной точностью. Функция `check_formatting(document: str, template: DocumentTemplate) -> ComplianceCheckItem`.
   - 9.7 [PENDING] Проверка 6 - Соответствие полномочиям: описать проверку, что документ соответствует полномочиям должности. Контроль должен проверить: (1) Тип документа в списке `allowed_document_types` должности; (2) Флаг `is_within_authority` установлен в `true`; (3) Если были документы эскалации - они обработаны корректно. Функция `check_authority_compliance(document: DocumentTask, position: UserPosition) -> ComplianceCheckItem`.
   - 9.8 [PENDING] Проверка 7 - Отсутствие изобретенной информации: описать проверку, что в документе нет информации, которой нет в `verified_data`. Контроль должен сравнить все данные в документе с верифицированными данными и убедиться, что ничего не добавлено от себя. Функция `check_no_invented_data(document: str, verified_data: dict, template: DocumentTemplate) -> ComplianceCheckItem`.
   - 9.9 [PENDING] Проверка 8 - Соответствие шаблону: описать проверку, что документ соответствует использованному шаблону. Контроль должен проверить: (1) Все обязательные секции присутствуют; (2) Структура соответствует шаблону; (3) Плейсхолдеры заполнены корректно. Функция `check_template_compliance(document: str, template: DocumentTemplate) -> ComplianceCheckItem`.
   - 9.10 [PENDING] Логика финального контроля: описать алгоритм выполнения всех проверок для всех документов в списке. Контроль должен: (1) Выполнить все проверки для каждого документа; (2) Создать `ComplianceReport` для каждого документа; (3) Определить общий статус (`is_ready`) - все документы готовы только если все проверки пройдены; (4) Собрать список всех проблем (`issues`) для исправления; (5) Если есть проблемы - вернуть workflow к соответствующему этапу (сбор данных, верификация, генерация) или запросить уточнения. Функция `perform_compliance_check(documents: list[DocumentTask], context: OfficialAgentContext) -> ComplianceReports`.
   - 9.11 [PENDING] Критерии готовности к отправке: описать четкие критерии, когда документ считается готовым к отправке: (1) Все проверки из чек-листа пройдены (`overall_status == passed`); (2) Нет критических проблем (`issues` пуст или содержит только предупреждения); (3) Все обязательные данные собраны; (4) Документ соответствует всем стандартам. Только при выполнении всех критериев `is_ready = true` и документ может быть отправлен.
10. Спланировать интеграцию субагентов в текущий пайплайн `sgr_deep_research`.
   - 10.1 [PENDING] Регистрация инструментов: описать процесс регистрации новых инструментов (RoleAnalyzerTool, TaskClassifierTool, DataPlannerTool, DataVerifierTool, DocumentBuilderTool, ComplianceCheckerTool) в `ToolRegistry`. Инструменты должны наследоваться от `BaseTool` (из `sgr_deep_research/core/tools`). Регистрация происходит через декоратор или явную регистрацию в `default_definitions.py` или через YAML-конфиги.
   - 10.2 [PENDING] Создание субагентов из инструментов: описать механизм создания субагентов внутри инструментов. Инструмент должен иметь доступ к `AgentFactory` для создания субагента с нужной конфигурацией (qwen3-32b или DeepSeek). Инструмент передает субагенту промпт, субагент возвращает текстовый ответ, инструмент парсит ответ и сохраняет структурированные данные в `ResearchContext.custom_context`.
   - 10.3 [PENDING] Конфигурация инструментов и субагентов: описать, как инструменты получают конфигурацию для создания субагентов (какой LLM использовать, какие промпты, какие параметры). Конфигурация должна быть доступна через `AgentConfig` из `ResearchContext.config` или через отдельные настройки в `default_definitions.py`/YAML.
   - 10.4 [PENDING] Порядок вызова инструментов в workflow: описать, как главный агент определяет, какой инструмент вызывать на каждом этапе. Инструменты должны быть доступны в `toolkit` главного агента, и главный агент выбирает нужный инструмент на основе текущего состояния `ResearchContext` и `OfficialAgentContext`. Workflow определяется логикой главного агента (последовательность из пункта 3.1).
   - 10.5 [PENDING] Передача данных между инструментами: описать, как данные передаются между инструментами через `ResearchContext.custom_context.OfficialAgentContext`. Каждый инструмент читает нужные данные из контекста, выполняет свою задачу, и сохраняет результаты обратно в контекст. Данные также доступны через `conversation` history для контекста LLM.
   - 10.6 [PENDING] Обработка ошибок и эскалаций: описать, как инструменты обрабатывают ошибки (недоступность субагента, ошибки парсинга, недостаток данных) и инициируют эскалации. Инструменты должны возвращать понятные ошибки, которые главный агент может обработать (запрос уточнений, эскалация, повтор попытки).
11. Сформировать сценарии тестирования с ожидаемыми результатами (без запуска).
   - 11.1 [PENDING] Сценарий 1 - Базовый успешный сценарий: описать тестовый сценарий с простым запросом на создание одного документа в пределах полномочий должности. Входные данные: запрос пользователя, должность с достаточными полномочиями, все необходимые данные доступны. Ожидаемый результат: все этапы workflow выполнены успешно, документ сгенерирован, все проверки пройдены, `is_ready = true` для документа.
   - 11.2 [PENDING] Сценарий 2 - Множественные документы: описать сценарий, когда в рамках одной задачи требуется создать несколько документов. Входные данные: запрос, требующий несколько документов. Ожидаемый результат: все документы определены, обработаны, сгенерированы, все проверки пройдены для каждого документа.
   - 11.3 [PENDING] Сценарий 3 - Превышение полномочий с эскалацией: описать сценарий, когда запрашиваемый документ выходит за пределы полномочий должности. Входные данные: запрос на документ, требующий более высокого уровня полномочий. Ожидаемый результат: обнаружено превышение полномочий, создан документ эскалации, добавлен в список документов, обработан вместе с основным запросом.
   - 11.4 [PENDING] Сценарий 4 - Недостаток данных: описать сценарий, когда часть необходимых данных недоступна. Входные данные: запрос, для которого некоторые данные из плана сбора недоступны. Ожидаемый результат: обнаружены отсутствующие данные, созданы запросы к ответственным сторонам или эскалация, документ не сгенерирован до получения всех данных, `is_ready = false`.
   - 11.5 [PENDING] Сценарий 5 - Противоречивые данные: описать сценарий, когда источники предоставляют противоречивую информацию. Входные данные: данные из разных источников противоречат друг другу. Ожидаемый результат: противоречия зафиксированы, попытка разрешения через приоритизацию источников, если не удалось - эскалация с запросом уточнения, документ не сгенерирован до разрешения конфликта.
   - 11.6 [PENDING] Сценарий 6 - Необходимость обращения к законодательству РФ: описать сценарий с неоднозначной проблемой (например, снос здания, вырубка зеленых насаждений). Входные данные: запрос, требующий обращения к федеральному законодательству. Ожидаемый результат: определено, что требуется законодательство РФ, данные собраны из правовых баз, использованы в документе.
   - 11.7 [PENDING] Сценарий 7 - Задержка получения данных более 24 часов: описать сценарий, когда данные не получены в течение 24 часов. Входные данные: запрос данных, которые не получены в течение 24 часов. Ожидаемый результат: создано уведомление для непосредственного руководителя с описанием отсутствующих данных и причин задержки.
   - 11.8 [PENDING] Сценарий 8 - Неясность типа документа: описать сценарий, когда тип документа не может быть однозначно определен. Входные данные: неоднозначный запрос пользователя. Ожидаемый результат: запрос уточнений через `ClarificationTool` с вопросами о назначении и цели документа, после получения уточнений - определение типа документа.
   - 11.9 [PENDING] Сценарий 9 - Валидация языковых требований: описать сценарий проверки, что все документы на русском языке. Входные данные: запрос, который может привести к смешению языков. Ожидаемый результат: все сгенерированные документы полностью на русском языке, проверка языка пройдена в финальном контроле.
   - 11.10 [PENDING] Сценарий 10 - Проверка отсутствия изобретенной информации: описать сценарий проверки, что в документе нет данных, которых нет в верифицированных источниках. Входные данные: запрос с ограниченным набором данных. Ожидаемый результат: документ содержит только данные из `verified_data`, проверка на отсутствие изобретенной информации пройдена.
   - 11.11 [PENDING] Сценарий 11 - Интеграция всех компонентов: описать комплексный сценарий, проверяющий работу всех инструментов и субагентов вместе. Входные данные: сложный запрос, требующий всех этапов workflow. Ожидаемый результат: все инструменты вызваны в правильном порядке, данные корректно передаются между этапами, все субагенты работают, финальные документы готовы.
   - 11.12 [PENDING] Сценарий 12 - Обработка ошибок: описать сценарии обработки различных ошибок (недоступность субагента, ошибки парсинга, недоступность источников данных). Входные данные: запросы, приводящие к различным типам ошибок. Ожидаемый результат: ошибки обработаны корректно, пользователь получил понятные сообщения, система не упала, возможна повторная попытка или эскалация.

Формат детализации: под каждым пунктом, по мере необходимости и после согласования, добавляем подзадачи вида "7.1, 7.2 …" с краткими описаниями и статусами.
Каждый пункт или подпункт после завершения должен своевременно получать отметку статуса (например, изменить `[PENDING]` на `[DONE]`).

